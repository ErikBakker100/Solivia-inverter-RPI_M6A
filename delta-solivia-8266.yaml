# *****************************************************************
# *          ESPHome Custom Component Modbus sniffer for          *
# *              Delta Solvia Inverter RPI M6A               *
# *             installed with Solivia Gateway M1 D2.             *
# *****************************************************************
#
# Remember to copy the Custom Component soliviaM6A.h file to the ESPHome folder in
# Home Assistant !!
#
# This config doesn't send any commands to the inverter !!
# Instead it relies on the gateways constant request for data (appx. 1 package pr. second).
#
# If you don't have a gateway, the package request can instead easily be send from
# ESPHome using uart.write and eg. triggered via the ESPHome Time component.
#
# Example:
# time:
#   - platform: homeassistant
#     id: esptime
#   - platform: sntp
#     on_time:
#        # Request package every 10 seconds from inverter at slave address: 0x01
#       - seconds: /10
#         then:
#           - uart.write: [0x02, 0x05, 0x01, 0x02, 0x60, 0x01, 0x85, 0xFC, 0x03]
# 
#
# NOTE !!
# 
# Most common inverter response length is 150 bytes (0x96) or 158 (0x9E).
#
# A list of all Delta Solivia inverters registers and the communication protocol is published
# and can be found here: https://forums.ni.com/ni/attachments/ni/170/1007166/1/Public%20RS485%20Protocol%201V2.pdf
#
# Using above list, it will be easy to tweak my configuration to fit your inverter variant.
#
# I have tweaked this config and revised the registers to get a working solution
# for my Delta Solivia RPI M6A: https://github.com/ErikBakker100/Solivia-Inverter-RPIM6A
#
# Tested on both ESP8266 with software & hardware uart and ESP32 with hardware uart only.
# I experience minor ESPHome <--> Home Assistant connection issues using the ESP8266 software uart.
# So I've revised my production config to use the hw uart pins instead. This is rock solid.
# But remember to turn off debug communication on the uart pins.
#
# My config:
# Inverter part no.: 602FA0E1000
#
# MQTT is enabled, no Home Assistant
# Double string input 4500W
# Three phase output: L1, L2, L3
# Slave address: 0x01
# Baud rate: 19200
# Install country: Netherlands
#
# Gateway request: 02:05:01:02:60:01:85:FC:03
# Inverter response: 02:06:01:A0:60:01 + 128 data bytes (excl. CRC bytes) + ETX byte
#
# The response matches the protocol, as well as the CRC bytes and trailing
# CRC bytes and ETX byte should be excluded from data length identifier (0xA0)
# 
# Commmand for eg. inverters serial no. is working ok on my inverter.
# - uart.write: [0x02, 0x05, 0x01, 0x02, 0x00, 0x01, 0xAD, 0xFC, 0x03] will response
# correctly with serial no.

esphome:
  name: "delta-solivia-8266"
  platform: ESP8266
  board: esp12e
  includes:
    - soliviaM6A.h
    
# Enable logging
# Set baud_rate to 0 if you're using hw uart, in order to disable logging via uart pins
logger:
  baud_rate: 0
#  level: VERBOSE 

# Enable Home Assistant API
#api:
#  encryption:
#    key: "my_api_key"

# Enable MQTT
mqtt:
  broker: 192.168.1.21
  username: ............
  password: ............

ota:
  password: ".............."

wifi:
  ssid: ".............."
  password: "............."
  manual_ip:
    static_ip: 192.168.1.X
    gateway: 192.168.1.1
    subnet: 255.255.255.0
  
  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Solivia_8266 Fallback Hotspot"
    password: "..........."

captive_portal:

# Remove hash signs and activate, if you don't have a Solivia gataway.
# With this you emulate the gateways request for data response from the inverter.
# With settings below, the requests are send every 10 seconds.
#
#time:
#  - platform: homeassistant
#    id: esptime
#  - platform: sntp
#    on_time:
#       # Request package every 10 seconds from inverter at slave address: 0x01
#      - seconds: /10
#        then:
#          - uart.write: [0x02, 0x05, 0x01, 0x02, 0x60, 0x01, 0x85, 0xFC, 0x03]

binary_sensor:
  - platform: status
    name: "Solar Node Status"
    id: solivia_status
  - platform: template
    name: "Solivia night status"
    # Check bit 2 for night status
    lambda: |-
      if (((int(id(solar_status_1).state)) >> (2)) & 1) return 1; else return 0;

# Example on how to return a text string instead of the binary inverter night status 
#text_sensor:
#  - platform: template
#    name: "Solivia night status"
#    # Check bit 2 for night status
#    lambda: |-
#      if (((int(id(solar_status_1).state)) >> (2)) & 1) return (std::string)"Inverter idle"; else return (std::string)"Inverter active";

uart:
  id: mod_bus
  #tx_pin: 17 # Typical tx pin for hardware UART#2 on ESP32 modules
  #rx_pin: 16 # Typical rx pin for hardware UART#2 on ESP32 modules
  #tx_pin: 5 # D1 ESP8266 tx pin for soft serial uart
  #rx_pin: 4 # D2 ESP8266 rx pin for soft serial uart
  tx_pin: 1 # D10 ESP8266 tx pin for hw serial uart
  rx_pin: 3 # D9 ESP8266 tx pin for hw serial uart
  # Increase buffer size as total package we're sniffing is 262 bytes in total
  # Inverter reply: 6 bytes + Data: 255 bytes + ETX: 1 byte = 262 bytes
  rx_buffer_size: 512
  baud_rate: 19200
  parity: NONE
  stop_bits: 1
  #debug: # Activate if you need to investigate package details in the log

sensor:
- platform: custom
  lambda: |-
    auto delta = new solivia(id(mod_bus));
    App.register_component(delta);
    return {delta->part, delta->serial, delta->ac_v1, delta->ac_a1, delta->ac_p1, delta->ac_f1, delta->ac_v2, delta->ac_a2, delta->ac_p2, delta->ac_f2, delta->ac_v3, delta->ac_a3, delta->ac_p3, delta->ac_f3, delta->dc_v1, delta->dc_a1, delta->dc_p1, delta->dc_v2, delta->dc_a2, delta->dc_p2};
  sensors:
  - name: "Solar part number"
    #icon: mdi:SolarPowerVariant
    # Frequent update, as sensor is used to calculate consumption with iem3155 sensor.total_active_power
    filters:
    - throttle: 100s 

  - name: "Solar serial number"
    #icon: mdi:SolarPowerVariant
    # Frequent update, as sensor is used to calculate consumption with iem3155 sensor.total_active_power
    filters:
    - throttle: 100s 

  - name: "Solar AC voltage L1"
    #icon: mdi:SolarPowerVariant
    device_class: energy
    unit_of_measurement: V
    accuracy_decimals: 1
    # Frequent update, as sensor is used to calculate consumption with iem3155 sensor.total_active_power
    filters:
    - throttle: 1s
    - multiply: 0.1
    
  - name: "Solar AC current L1"
    #icon: mdi:SolarPowerVariant
    device_class: energy
    unit_of_measurement: V
    accuracy_decimals: 2
    # Frequent update, as sensor is used to calculate consumption with iem3155 sensor.total_active_power
    filters:
    - throttle: 1s
    - multiply: 0.01
    
  - name: "Solar AC power L1"
    #icon: mdi:SolarPowerVariant
    device_class: energy
    unit_of_measurement: W
    accuracy_decimals: 0
    # Frequent update, as sensor is used to calculate consumption with iem3155 sensor.total_active_power
    filters:
    - throttle: 1s

  - name: "Solar AC frequency L1"
    device_class: energy
    unit_of_measurement: Hz
    accuracy_decimals: 2
    filters:
    - throttle: 1s
    - multiply: 0.01
    
  - name: "Solar AC voltage L2"
    #icon: mdi:SolarPowerVariant
    device_class: energy
    unit_of_measurement: V
    accuracy_decimals: 1
    # Frequent update, as sensor is used to calculate consumption with iem3155 sensor.total_active_power
    filters:
    - throttle: 1s
    - multiply: 0.1
    
  - name: "Solar AC current L2"
    #icon: mdi:SolarPowerVariant
    device_class: energy
    unit_of_measurement: V
    accuracy_decimals: 2
    # Frequent update, as sensor is used to calculate consumption with iem3155 sensor.total_active_power
    filters:
    - throttle: 1s
    - multiply: 0.01
    
  - name: "Solar AC power L2"
    #icon: mdi:SolarPowerVariant
    device_class: energy
    unit_of_measurement: W
    accuracy_decimals: 0
    # Frequent update, as sensor is used to calculate consumption with iem3155 sensor.total_active_power
    filters:
    - throttle: 1s

  - name: "Solar AC frequency L2"
    device_class: energy
    unit_of_measurement: Hz
    accuracy_decimals: 2
    filters:
    - throttle: 1s
    - multiply: 0.01
    
    - name: "Solar AC voltage L3"
    #icon: mdi:SolarPowerVariant
    device_class: energy
    unit_of_measurement: V
    accuracy_decimals: 1
    # Frequent update, as sensor is used to calculate consumption with iem3155 sensor.total_active_power
    filters:
    - throttle: 1s
    - multiply: 0.1
    
  - name: "Solar AC current L3"
    #icon: mdi:SolarPowerVariant
    device_class: energy
    unit_of_measurement: V
    accuracy_decimals: 2
    # Frequent update, as sensor is used to calculate consumption with iem3155 sensor.total_active_power
    filters:
    - throttle: 1s
    - multiply: 0.01
    
  - name: "Solar AC power L3"
    #icon: mdi:SolarPowerVariant
    device_class: energy
    unit_of_measurement: W
    accuracy_decimals: 0
    # Frequent update, as sensor is used to calculate consumption with iem3155 sensor.total_active_power
    filters:
    - throttle: 1s

  - name: "Solar AC frequency L3"
    device_class: energy
    unit_of_measurement: Hz
    accuracy_decimals: 2
    filters:
    - throttle: 1s
    - multiply: 0.01
    
   - name: "Solar DC voltage line 1"
    device_class: energy
    unit_of_measurement: V
    accuracy_decimals: 1
    filters:
    - throttle: 1s
    - multiply: 0.1

- name: "Solar DC current line 1"
    device_class: energy
    unit_of_measurement: A
    accuracy_decimals: 2
    filters:
    - throttle: 1s
    - multiply: 0.01
  
- name: "Solar DC power line 1"
    device_class: energy
    unit_of_measurement: W
    accuracy_decimals: 0
    filters:
    - throttle: 1s
  
   - name: "Solar DC voltage line 2"
    device_class: energy
    unit_of_measurement: V
    accuracy_decimals: 1
    filters:
    - throttle: 1s
    - multiply: 0.1

- name: "Solar DC current line 2"
    device_class: energy
    unit_of_measurement: A
    accuracy_decimals: 2
    filters:
    - throttle: 1s
    - multiply: 0.01
  
- name: "Solar DC power line 2"
    device_class: energy
    unit_of_measurement: W
    accuracy_decimals: 0
    filters:
    - throttle: 1s
  


# Complete 'live' package example - captured [2022-08-08 10:32:54 GMT+1]:

# Request:  02:05:01:02:60:01:85:FC:03
# Response: 02:06:01:FF:60:01

# Package data:
# 0x00   45:4F:45:34:36:30:31:30:32:38:37:31:31:33:32:38
# 0x10   37:30:38:31:33:30:31:30:30:33:33:39:38:31:33:30
# 0x20   31:30:38:01:02:1A:00:00:00:00:23:34:00:00:00:00
# 0x30   23:34:00:00:00:00:00:00:00:00:00:00:23:34:00:00
# 0x40   00:00:00:00:00:00:00:00:01:00:03:96:01:9A:00:16
# 0x50   00:00:00:00:00:00:00:00:00:00:00:00:00:23:00:EC
# 0x60   13:88:03:64:FF:4E:00:00:00:00:00:00:00:00:00:00
# 0x70   00:00:00:00:00:00:00:00:00:00:08:98:07:D0:00:33
# 0x80   00:33:00:00:00:00:02:14:3E:3E:00:26:48:A6:00:00
# 0x90   00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00
# 0xA0   00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00
# 0xB0   00:00:00:00:08:F7:00:00:01:16:00:00:00:00:00:00
# 0xC0   00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00
# 0xD0   00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00
# 0xE0   00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00
# 0xF0   00:00:00:00:00:00:00:00:00:00:00:00:00:34:A4:03

# Register address:
# 0x00 - 0x0A:  SAP part no.                EOE46010287           45:4F:45:34:36:30:31:30:32:38:37
# 0x0B - 0x1C:  SAP serial no.              113287081301003398    31:31:33:32:38:37:30:38:31:33:30:31:30:30:33:33:39:38
# 0x1D - 0x20:  SAP date code               1301                  31:33:30:31
# 0x21 - 0x22:  SAP revision                08                    30:38
# 0x23 - 0x25:  SW rev. System controller   1.02.26               01:02:1A
# 0x29 - 0x2B:  SW rev. ENS controller      0.35.52               00:23:34
# 0x2F - 0x31:  SW Rev. DC controller       0.35.52               00:23:34
# 0x3B - 0x3D:  SW Rev. AC controller       0.35.52               00:23:34
# 0x47 - 0x49:  SW revision reserved        0.1.0                 00:01:00
# 0x4A - 0x4B:  DC Power PV1 W              918                   03:96
# 0x4C - 0x4D:  DC voltage PV1 V            410                   01:9A
# 0x4E - 0x4F:  DC current PV1 (2,2 A)      22                    00:16
# 0x5C - 0x5D:  AC current L1 (3,5 A)       35                    00:23
# 0x5E - 0x5F:  AC voltage L1 V             236                   00:EC
# 0x60 - 0x61:  AC frequency (50,00 Hz)     5000                  13:88
# 0x62 - 0x63:  AC Power L1 W               868                   03:64
# 0x64 - 0x65:  AC Reactive Power L1 VAR    -178                  FF:4E
# 0x7A - 0x7B:  ISO+ resistance kΩ          2200                  08:98
# 0x7C - 0x7D:  ISO- resistance kΩ          2000                  07:D0
# 0x7E - 0x7F:  Temperature ambient °C      50                    00:33
# 0x80 - 0x81:  Temperature heatsink °C     50                    00:33
# 0x86 - 0x89:  Total yield (34881,086 kWh) 34881086              02:14:3E:3E
# 0x8A - 0x8D:  Uptime total in minutes     2508966               00:26:48:A6
# 0x91 - 0x91:  Status 1 - bit 0 to 7       0                     00
# 0x94 - 0x94:  Status 2 - bit 8 to 15      0                     00
# 0xB4 - 0xB5:  Daily power yield Wh        2295                  08:F7
# 0xB8 - 0xB9:  Uptime today in minutes     278                   01:16

# 0x91: Inverter status register 1 (4 bytes - 32 bits in total):
# bit 00 = 1 -> Self test ongoing
# bit 01 = 1 -> Firmware update
# bit 02 = 1 -> Night mode                   Check for Night mode
# bit 03 = 1 -> L1 Voltage failure           Check for L1 Voltage failure
# bit 04 = 1 -> L2 Voltage failure
# bit 05 = 1 -> L3 Voltage failure
# bit 06 = 1 -> L1 Frequency failure
# bit 07 = 1 -> L2 Frequency failure

# When inverter is active bit#02 is cleared. When inactive bit#02 is set.

# 0x94: Inverter status register 2 (4 bytes - 32 bits in total):

# bit 08 = 1 -> PV3 Iso startup failure
# bit 09 = 1 -> PV3 Iso running failure
# bit 10 = 1 -> PV3+ grounding failure
# bit 11 = 1 -> PV3- grounding failure
# bit 12 = 1 -> PV1 voltage too low failure   Check for PV1 voltage too low failure
# bit 13 = 1 -> PV2 voltage too low failure
# bit 14 = 1 -> PV3 voltage too low failure
# bit 15 = 1 -> Internal failure
